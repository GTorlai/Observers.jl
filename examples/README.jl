#' [![Tests](https://github.com/GTorlai/Observers.jl/workflows/Tests/badge.svg)](https://github.com/GTorlai/Observers.jl/actions?query=workflow%3ATests)
#' [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

#' # Observers.jl

#' The Observers.jl package provides functionalities to record and track metrics of interest
#' during the iterative evaluation of a given function. It may be used to monitor convergence
#' of optimization algorithms, measure revelant observables in numerical simulations,
#' print useful information from an iterative method, etc.

#' ## News

#' Observers.jl v0.2 has been released, which preserves the same basic `update!`
#' interface but a new design of the observer object, which is now
#' now just a `DataFrame` from
#' [DataFrames.jl](https://dataframes.juliadata.org/stable/). The basic constructor
#' syntax is the same, though `Observer` has been deprecated in favor of `observer`.
#' See the rest of this [README](https://github.com/GTorlai/Observers.jl#readme), the
#' [examples/](https://github.com/GTorlai/Observers.jl/tree/main/examples)
#' and [test/](https://github.com/GTorlai/Observers.jl/tree/main/test) directories, and
#' the [DataFrames.jl documentation](https://dataframes.juliadata.org/stable/)
#' to learn about how to use the new observer type.

#' ## Installation

#' You can install this package through the Julia package manager:
#' ```julia
#' julia> ] add Observers
#' ```

#' ## Basic Usage

#+ results="hidden"

using Observers: observer

# Series for π/4
f(k) = (-1)^(k + 1) / (2k - 1)

function my_iterative_function(niter; observer!, observe_step)
  π_approx = 0.0
  for n in 1:niter
    π_approx += f(n)
    if iszero(n % observe_step)
      Observers.update!(observer!; iteration=n, π_approx=4π_approx)
    end
  end
  return 4π_approx
end

# Record the iteration
iteration(; iteration) = iteration

# Measure the relative error from π at each iteration
error(; π_approx) = abs(π - π_approx) / π

obs = observer(iteration, error)

niter = 10000

#' Now we run the function and analyze the results:
#+ term=true
π_approx = my_iterative_function(niter; (observer!)=obs, observe_step=1000)

#' Results will be saved in the observer, which is just a `DataFrame` from the Julia
#' package [DataFrames.jl](https://dataframes.juliadata.org/stable/) but with
#' functions associated with each column that get called to generate new rows
#' of the data frame. You can view the results as a table of data by printing it:
#+ term=true
obs

#' Columns store the results from each function that was passed, which can be accessed
#' with the standard `DataFrame` interface:
#+ term=true
obs.error
obs[!, "error"] == obs.error # DataFrames view access syntax
obs[!, :error] == obs.error # Can use Symbols
obs[:, "error"] == obs.error # Copy the column
obs[:, :error] == obs.error # Can use Symbols
obs[!, string(error)] == obs.error # Access using function
obs[!, Symbol(error)] == obs.error # Access using function

#' You can perform various operations like slicing:
#+ term=true
obs[4:6, :]

#' See the [DataFrames.jl documentation](https://dataframes.juliadata.org/stable/)
#' documentation for more information on operations you can perform,
#' along with the [examples/](https://github.com/GTorlai/Observers.jl/tree/main/examples) and
#' [test/](https://github.com/GTorlai/Observers.jl/tree/main/test) directory.
#' You will have to load DataFrames.jl with `using DataFrames` to access DataFrame
#' functions.

#' ## Custom column names

#' Alternatively, you can pass string names with the functions which will become
#' the names of the columns of the observer:
#+ term=true
obs = observer("Iteration" => iteration, "Error" => error)

#' in which case the results can be accessed from the given specified name:
#+ term=true
obs.Error
obs.Iteration

#' This is particularly useful if you pass anonymous functions into the observer,
#' in which case the automatically generated name of the column would be randomly generated.
#' For example:
#+ term=true
obs = observer((; iteration) -> iteration, (; π_approx) -> abs(π - π_approx) / π)
π_approx = my_iterative_function(niter; (observer!)=obs, observe_step=1000)
obs

#' You can see that the names of the functions are automatically generated by Julia, since they are
#' [anonymous functions](https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions).

#' This will make the results harder to access by name, but you can still use
#' positional information since the columns are ordered based on how
#' the observer was defined:
#+ term=true
obs[!, 1]
obs[!, 2]

#' You could also save the anonymous functions in variables and use
#' them to access the results:
#+ term=true
iter = (; iteration) -> iteration
err = (; π_approx) -> abs(π - π_approx) / π
obs = observer(iter, err)
π_approx = my_iterative_function(niter; (observer!)=obs, observe_step=1000)
obs

#' You can use the functions themselves to access results, as long as you convert
#' them to strings or symbols:
#+ term=true
obs[!, string(iter)]
obs[!, Symbol(err)]

#' You can also rename the columns to more desirable names using the `rename!`
#' function from `DataFrames`:
#+ term=true
using DataFrames: rename!
rename!(obs, ["Iteration", "Error"])
obs.Iteration
obs.Error

#' Column functions will be preserved even if the columns are renamed (and in
#' any other operation in which DataFrames.jl preserves so-called `:note`-style
#' metadata, see the
#' [DataFrames.jl documentation on metadata](https://dataframes.juliadata.org/stable/lib/metadata/)
#' for more details.

#' ## Accessing and modifying functions

#' You can access and modify functions of an observer with `Observers.get_function`, `Observers.set_function!`, and `Observers.insert_function!`:
#+ term=true
Observers.get_function(obs, "Iteration") == iter
Observers.get_function(obs, "Error") == err
Observers.set_function!(obs, "Error" => sin);
Observers.get_function(obs, "Error") == sin
Observers.insert_function!(obs, "New column" => cos);
Observers.get_function(obs, "New column") == cos
obs

#' `Observers.set_function!` just updates the function of an existing column but doesn't create new columns,
#' while `Observers.insert_function!` creates a new column and sets the function of that new column
#' but won't update an existing column.
#' For example, these will both throw errors:
#' ```julia
#' Observers.set_function!(obs, "New column 2", cos)
#' Observers.insert_function!(obs, "Error", cos)
#' ```

#' Alternatively, if you define the observer with column names to begin with,
#' then you can get the results using the function names:
#+ term=true
obs = observer(
  "Iteration" => (; iteration) -> iteration,
  "Error" => (; π_approx) -> abs(π - π_approx) / π,
)
π_approx = my_iterative_function(niter; (observer!)=obs, observe_step=1000)
obs.Iteration
obs.Error

#' ## Reading and Writing to Disk

#' You can save and load observers with packages like [JLD2.jl](https://github.com/JuliaIO/JLD2.jl),
#' or any other packages you like:
#+ results="hidden"
using JLD2
jldsave("results.jld2"; obs)
obs_loaded = load("results.jld2", "obs")
#+ term=true
obs_loaded == obs
obs_loaded.Error == obs.Error

#' Another option is saving and loading as a
#' [CSV file](https://dataframes.juliadata.org/stable/man/importing_and_exporting/#CSV-Files),
#' though this will drop information about the functions associated with each column:
#+ results="hidden"
using CSV: CSV
using DataFrames: DataFrame
CSV.write("results.csv", obs)
obs_loaded = DataFrame(CSV.File("results.csv"))
#+ term=true
obs_loaded == obs
obs_loaded.Error == obs.Error

#' ## Generating this README

#' This [README](https://github.com/GTorlai/Observers.jl#readme) file was generated with
#' [Weave.jl](https://github.com/JunoLab/Weave.jl) with the following commands:
#+ eval=false

using Observers: Observers
using Weave: Weave
Weave.weave(
  joinpath(pkgdir(Observers), "examples", "README.jl");
  doctype="github",
  out_path=pkgdir(Observers),
)
